#ifdef CMSSW_GIT_HASH
#include "HGCalTileSim/Tile/interface/LYSimDetectorConstruction.hh"
#include "HGCalTileSim/Tile/interface/LYSimDetectorMessenger.hh"
#include "HGCalTileSim/Tile/interface/Materials.hh"
#include "HGCalTileSim/Tile/interface/SurfaceProperty.hh"
#else
#include "LYSimDetectorConstruction.hh"
#include "LYSimDetectorMessenger.hh"
#include "Materials.hh"
#include "SurfaceProperty.hh"
#endif

#include <math.h>
#include <vector>

#include "G4Box.hh"
#include "G4Cons.hh"
#include "G4Ellipsoid.hh"
#include "G4GeometryManager.hh"
#include "G4IntersectionSolid.hh"
#include "G4LogicalBorderSurface.hh"
#include "G4LogicalSkinSurface.hh"
#include "G4LogicalVolume.hh"
#include "G4LogicalVolumeStore.hh"
#include "G4Material.hh"
#include "G4NistManager.hh"
#include "G4Orb.hh"
#include "G4PhysicalVolumeStore.hh"
#include "G4PVPlacement.hh"
#include "G4RegionStore.hh"
#include "G4RotationMatrix.hh"
#include "G4RunManager.hh"
#include "G4SDManager.hh"
#include "G4SolidStore.hh"
#include "G4Sphere.hh"
#include "G4SubtractionSolid.hh"
#include "G4SystemOfUnits.hh"
#include "G4Trap.hh"
#include "G4Trd.hh"
#include "G4Tubs.hh"
#include "G4UnionSolid.hh"
#include "G4UnitsTable.hh"
#include "G4VisAttributes.hh"
#include "G4VPhysicalVolume.hh"

using std::cos;
using std::sin;
using std::tan;
using std::atan;
using std::exp;
using namespace CLHEP;

LYSimPMTSD* LYSimDetectorConstruction::fPMTSD = NULL;

LYSimDetectorConstruction::LYSimDetectorConstruction()
  : G4VUserDetectorConstruction()
{
  fdetectorMessenger = new LYSimDetectorMessenger( this );

  _tilex        = 30*mm;//29.65*mm;
  _tiley        = 30*mm;//29.65*mm;
  _tilez        = 3.0*mm;//3.0*mm;
  _tile_x1      = 0.0*mm;
  _tile_x2      = 0.0*mm;
  wrapgap       = 0.065*mm;
  wrapthickness = 0.1*mm;

  tilegap = 0.1*mm;//another probability 0.5*mm
  tile_number = 1;
  is_ESR = true;
  material = 1;

  _absmult      = 1;
  _wrap_reflect = 0.985;

  _sipm_deadwidth  = 0.2*mm;
  _sipm_x          = 1.3*mm;
  _sipm_y          = 1.3*mm;
  _sipm_z          = 0.35*mm;
  _sipm_rimwidth   = 0.4*mm;
  _sipm_glasswidth = 0.3*mm;


  _sipm_standz     = 0.2*mm;  // used as dx
  _gap_pcb_wrap    = 0.2*mm;  // used as dy

_sipm_standz_ = 0.2*mm;
_gap_pcb_wrap_ = 0;
_sipm_standz_ = _sipm_standz;
_gap_pcb_wrap_ = _gap_pcb_wrap;

  // Default Dimple settings
  _dimple_type   = SPHERICAL;// 0: Normal, 1: Pyramid, 2: Parabolic
  _dimple_indent = 1.6*mm;//1.6*mm;
  _dimple_radius = 2.65*mm;//3.5*mm;// 3.4409*mm

  // Default Hole settings
  _pcb_radius       = 3.175;
  _pcb_reflectivity = 0.5;


  // Defining material list.
  fBialkali = Make_Bialkali();
  fEpoxy    = Make_Epoxy();
  fAir      = Make_Custom_Air();
  if(material==1){ fEJ200    = Make_EJ200();}else{fEJ200    = Make_SCSN81();}
  //fEJ200    = Make_EJ200();
 
//  scsn81    = Make_SCSN81();
  fResin    = Make_Resin();
  fBC_630_grease = Make_BC_630_grease();
  SetTileAbsMult( _absmult );

  // Defining surface list.
  fTyvekSurface           = MakeS_TyvekCrystal();
  fESROpSurface           = MakeS_Rough();
  fPolishedOpSurface      = MakeS_Polished();
  fIdealPolishedOpSurface = MakeS_IdealPolished();
  fIdealWhiteOpSurface    = MakeS_IdealWhiteSurface();
  fSiPMSurface            = MakeS_SiPM();
  fPCBSurface             = MakeS_PCBSurface();
  SetWrapReflect( _wrap_reflect );
}

void
LYSimDetectorConstruction::UpdateGeometry()
{
  // clean-up previous geometry
  G4GeometryManager::GetInstance()->OpenGeometry();

  G4PhysicalVolumeStore::GetInstance()->Clean();
  G4LogicalVolumeStore::GetInstance()->Clean();
  G4SolidStore::GetInstance()->Clean();
  G4LogicalSkinSurface::CleanSurfaceTable();
  G4LogicalBorderSurface::CleanSurfaceTable();

  G4RunManager::GetRunManager()->DefineWorldVolume( Construct() );
  G4RunManager::GetRunManager()->GeometryHasBeenModified();
}

LYSimDetectorConstruction::~LYSimDetectorConstruction()
{
  if( fdetectorMessenger ){ delete fdetectorMessenger; }
}

G4VPhysicalVolume*
LYSimDetectorConstruction::Construct()
{

double   SetupDX = 25.0*mm;
double  SetupDY = 10.0*mm;
double  SetupDZ = 25.0*mm;

double  TriggerDX = 15.0*mm;
double  TriggerDY = 1.5*mm;
double  TriggerDZ = 15.0*mm;
double  TriggerYposition = -SetupDY + 2.5*TriggerDY;

double  TileDX = 15.0*mm;
double  TileDY = 1.5*mm;
double  TileDZ = 15.0*mm; 
double  FoilThickness = 65*um / 2;

double  HoleRadius = 4.00*mm;
double  HoleDepth  = 1.6*mm;

double  slabXZexcess = 5*mm;
double  SlabDX = TileDX + slabXZexcess;
double  SlabDY = 0.1*mm;
double  SlabDZ = TileDZ + slabXZexcess;
double  AirGapDY = 0.01*mm;
double  SlabYposition = TileDY + AirGapDY + SlabDY + FoilThickness * 2;

double  SipmBoxDX = 1.9*mm;
double  SipmBoxDY = 0.5*mm;
double  SipmBoxDZ = 1.9*mm;

double  SipmContactDX = 0.6*mm;
double  SipmContactDY = 0.2*mm;
double  SipmContactDZ = 0.6*mm;
double  SipmContact1_Xshift = -SipmBoxDX + SipmContactDX; 
double  SipmContact1_Zshift = 0*mm; 
double  SipmContact2_Xshift = SipmBoxDX - SipmContactDX; 
double  SipmContact2_Zshift = 0*mm; 

double  EpoxyDX = SipmBoxDX;
double  EpoxyDY = 0.2*mm;
double  EpoxyDZ = SipmBoxDZ;
double  EpoxyYShift = -0.5*mm;
double  EpoxyYPosition = TileDY + EpoxyDY + EpoxyYShift;

double  SipmDX = 1.1*mm;
double  SipmDY = 0.5*mm;
double  SipmDZ = 1.1*mm;

double  SipmBoxYPosition = EpoxyYPosition + EpoxyDY + SipmBoxDY;
double  SipmYPosition = EpoxyYPosition + EpoxyDY + SipmDY;
double  SipmContactYPosition = SipmBoxYPosition + SipmBoxDY + SipmContactDY;


//===================================================================
// ------------- Materials -------------
//===================================================================


//===================================================================
// ------------- Volumes --------------
//===================================================================

// Setup
//
  G4Box* setup = new G4Box("World", SetupDX, SetupDY, SetupDZ);

  G4LogicalVolume* setup_log
    = new G4LogicalVolume(setup, FindMaterial("G4_AIR"),"World",0,0,0);

  G4VPhysicalVolume* setup_phys
    = new G4PVPlacement(0,
			G4ThreeVector(),
			setup_log,
			"World",
			0,
			false,
			0,
			true);

  G4cout << "-----!!!!!!! World constructed !!!!!------" << G4endl;
 // .......................................................................


// Trigger system
//
  G4Box* trigger = new G4Box("Trigger", TriggerDX, TriggerDY, TriggerDZ);

  G4LogicalVolume* trigger_log
    = new G4LogicalVolume(trigger, FindMaterial("G4_PLASTIC_SC_VINYLTOLUENE"),"Trigger",0,0,0);

  G4VPhysicalVolume* trigger_phys
    = new G4PVPlacement(0,
			G4ThreeVector(0, TriggerYposition, 0),
			trigger_log,
			"Trigger",
                        setup_log,
			false,
			0,
			true);

  G4cout << "-----!!!!!!! Trigger constructed !!!!!------" << G4endl;

// ................................................................................

// Extruded scintillator tile
//
  G4Box* tile_box = new G4Box("TileBox",  TileDX,  TileDY,  TileDZ);
  G4LogicalVolume* tile_log; 

  if ( HoleDepth > 0.0 ) { 
  //  G4RotationMatrix* rot = new G4RotationMatrix;
  //  rot->rotateX(M_PI/2.*rad);

  //  G4Paraboloid* paraboloid = new G4Paraboloid("Paraboloid", ( HoleDepth / 2.0 ) , 0.0*mm, HoleRadius);
    //G4ThreeVector yTrans(0.0, TileDY - ( HoleDepth / 2.0 ), 0.0);
    //G4VSolid* extrudedTile =
     // new G4SubtractionSolid("Tile", tile_box, paraboloid, rot, yTrans);
    G4double rBall = 0.5*( pow(HoleRadius,2) + pow(HoleDepth,2) )/HoleDepth;
    G4Orb* ball = new G4Orb("Ball", rBall);
    G4ThreeVector yTrans(0, TileDY + rBall - HoleDepth, 0);
    G4VSolid* extrudedTile = 
      new G4SubtractionSolid("Tile", tile_box, ball, 0, yTrans);
    tile_log
      = new G4LogicalVolume(extrudedTile, FindMaterial("G4_PLASTIC_SC_VINYLTOLUENE"),"Tile",0,0,0);
  }
  else {
    tile_log
      = new G4LogicalVolume(tile_box, FindMaterial("G4_PLASTIC_SC_VINYLTOLUENE"),"Tile",0,0,0);
  }
  G4VPhysicalVolume* tile_phys
    = new G4PVPlacement(0,
			G4ThreeVector(0.0,0.0,0.0),
			tile_log,
			"Tile",
                        setup_log,
			false,
			0,
			true);

  G4cout << "-----!!!!!!! Tile constructed !!!!!------" << G4endl;

// Tile 4-side + 2-side foil
// Side 1
  G4Box* side1 = new G4Box("Side1", FoilThickness, TileDY, TileDZ );

  G4LogicalVolume* side1_log
    = new G4LogicalVolume(side1, FindMaterial("G4_Al"),"Side1",0,0,0);

  G4VPhysicalVolume* side1_phys
    = new G4PVPlacement(0,
			G4ThreeVector(-(TileDX+FoilThickness),0.0,0.0),
			side1_log,
			"Side1",
                        setup_log,
			false,
			0,
			true);

// Side 2
  G4Box* side2 = new G4Box("Side2", TileDX, TileDY, FoilThickness );

  G4LogicalVolume* side2_log
    = new G4LogicalVolume(side2, FindMaterial("G4_Al"),"Side2",0,0,0);

  G4VPhysicalVolume* side2_phys
    = new G4PVPlacement(0,
			G4ThreeVector(0.0, 0.0, -(TileDZ+FoilThickness)),
			side2_log,
			"Side2",
                        setup_log,
			false,
			0,
			true);

// Side 3
  G4Box* side3 = new G4Box("Side3", FoilThickness, TileDY, TileDZ );

  G4LogicalVolume* side3_log
    = new G4LogicalVolume(side3, FindMaterial("G4_Al"),"Side3",0,0,0);

  G4VPhysicalVolume* side3_phys
    = new G4PVPlacement(0,
			G4ThreeVector((TileDX+FoilThickness),0.0,0.0),
			side3_log,
			"Side3",
                        setup_log,
			false,
			0,
			true);

// Side 4
  G4Box* side4 = new G4Box("Side4", TileDX, TileDY, FoilThickness );

  G4LogicalVolume* side4_log
    = new G4LogicalVolume(side4, FindMaterial("G4_Al"),"Side4",0,0,0);

  G4VPhysicalVolume* side4_phys
    = new G4PVPlacement(0,
			G4ThreeVector(0.0, 0.0, (TileDZ+FoilThickness)),
			side4_log,
			"Side4",
                        setup_log,
			false,
			0,
			true);

// Side 5
  G4Box* side5 = new G4Box("Side5", TileDX, FoilThickness, TileDZ );

  G4LogicalVolume* side5_log
    = new G4LogicalVolume(side5, FindMaterial("G4_Al"),"Side5",0,0,0);

  G4VPhysicalVolume* side5_phys
    = new G4PVPlacement(0,
			G4ThreeVector(0.0,-(TileDY+FoilThickness),0.0),
			side5_log,
			"Side5",
                        setup_log,
			false,
			0,
			true);

// Side 6

  G4RotationMatrix* rot3 = new G4RotationMatrix;
  rot3->rotateX(M_PI/2.*rad);

  G4Box* side6 = new G4Box("Side6", TileDX, FoilThickness, TileDZ );

  G4Tubs* cylinder = new G4Tubs("Cylinder", 0.0, HoleRadius, 1.0*m, 0.0*deg, 360.0*deg);

  G4VSolid* side6WithHole =
    new G4SubtractionSolid("Side6WithHole", side6, cylinder, rot3, G4ThreeVector(0.0, 0.0, 0.0));

  G4LogicalVolume* side6_log
    = new G4LogicalVolume(side6WithHole, FindMaterial("G4_Al"),"Side6",0,0,0);

  G4VPhysicalVolume* side6_phys
    = new G4PVPlacement(0,
			G4ThreeVector(0.0,(TileDY+FoilThickness),0.0),
			side6_log,
			"Side6",
                        setup_log,
			false,
			0,
			true);

  G4cout << "-----!!!!!!! Foil constructed !!!!!------" << G4endl;

	// Bottom reflecting slab
//
  G4Box* botSlab = new G4Box("BottomSlab", SlabDX, SlabDY, SlabDZ);

  G4LogicalVolume* botSlab_log
    = new G4LogicalVolume(botSlab, FindMaterial("G4_MYLAR"),"BottomSlab",0,0,0);

  G4VPhysicalVolume* botSlab_phys
    = new G4PVPlacement(0,
			G4ThreeVector(0.0,-SlabYposition,0.0),
			botSlab_log,
			"BottomSlab",
                        setup_log,
			false,
			0,
			true);
  
// Top reflecting slab with a hole for sipm box

  G4Box* topSlabSolid = new G4Box("TopSlabSolid", SlabDX, SlabDY, SlabDZ);
  G4Box* hole = new G4Box("Hole", SipmBoxDX, SlabDY, SipmBoxDZ);

//  G4Tubs* cylinder = new G4Tubs("Cylinder", 0.0*mm, 0.9925*mm, 2.0*mm, 0.0*deg, 360.0*deg);
//  G4ThreeVector zTrans(2.5, 0.0, 10.5);
//  G4RotationMatrix* rot3 = new G4RotationMatrix;
//  rot3->rotateX(M_PI/2.*rad); 

  G4VSolid* topSlabWithHole =
    new G4SubtractionSolid("TopSlabWithHole", topSlabSolid, hole, 0, G4ThreeVector(0.0, 0.0, 0.0));

//  G4VSolid* extrudedtopSlabWithHole = new G4SubtractionSolid("TopSlabWithHole_with_LED", topSlabWithHole, cylinder, rot3, zTrans);

  G4LogicalVolume* topSlab_log
    = new G4LogicalVolume(topSlabWithHole, FindMaterial("G4_MYLAR"),"TopSlab",0,0,0);

  G4VPhysicalVolume* topSlab_phys
    = new G4PVPlacement(0,
			G4ThreeVector(0.0, SlabYposition, 0.0), 
			topSlab_log,
			"TopSlab",
                        setup_log,
			false,
			0,
			true);

  G4cout << "-----!!!!!!! Slabs constructed !!!!!------" << G4endl;

  G4RotationMatrix* rot2 = new G4RotationMatrix;
  rot2->rotateX(0);  // -pi/15

// Epoxy layer in front of SiPM
//
  G4Box* epoxy = new G4Box("EpoxyBox", EpoxyDX, EpoxyDY, EpoxyDZ);

  G4LogicalVolume* epoxy_log
    = new G4LogicalVolume(epoxy, FindMaterial("Epoxy_resin"),"EpoxyBox",0,0,0);

  G4VPhysicalVolume* epoxy_phys
    = new G4PVPlacement(rot2,
			G4ThreeVector(0.0, EpoxyYPosition, 0.0), 
			epoxy_log,
			"EpoxyBox",
                        setup_log,
			false,
			0,
			true);

  G4cout << "-----!!!!!!! Epoxy constructed !!!!!------" << G4endl;

// SiPM box from epoxy 
//
  G4Box* sipmBoxSolid = new G4Box("SipmBoxSolid", SipmBoxDX, SipmBoxDY, SipmBoxDZ);
  G4Box* sipmHole = new G4Box("simpHole", SipmDX, SipmDY, SipmDZ);
  G4VSolid* simpBoxWithHole =
    new G4SubtractionSolid("SipmBoxWithHole", sipmBoxSolid, sipmHole, 0,
			   G4ThreeVector(0.0, -SipmBoxDY+SipmDY, 0.0));

  G4LogicalVolume* sipmbox_log
    //= new G4LogicalVolume(simpBoxWithHole, FindMaterial("G4_Si"),"SipmBox",0,0,0);
    = new G4LogicalVolume(simpBoxWithHole, FindMaterial("Epoxy_resin"),"SipmBox",0,0,0);

  G4VPhysicalVolume* sipmbox_phys
    = new G4PVPlacement(rot2,
			G4ThreeVector(0.0, SipmBoxYPosition, 0.0),  
			sipmbox_log,
			"SipmBox",
                        setup_log,
			false,
			0,
			true);

  G4cout << "-----!!!!!!! SiPM box constructed !!!!!------" << G4endl;

// SiPM contacts
//
  G4Box* cont1 = new G4Box("SipmContact1", SipmContactDX, SipmContactDY, SipmContactDZ);

  G4LogicalVolume* cont1_log
    = new G4LogicalVolume(cont1, FindMaterial("G4_Cu"),"SipmContact1",0,0,0);

  G4VPhysicalVolume* cont1_phys
    = new G4PVPlacement(rot2,
			G4ThreeVector(SipmContact1_Xshift, SipmContactYPosition, SipmContact1_Zshift),  
			cont1_log,
			"SipmContact1",
                        setup_log,
			false,
			0,
                        true);
//
  G4Box* cont2 = new G4Box("SipmContact2", SipmContactDX, SipmContactDY, SipmContactDZ);

  G4LogicalVolume* cont2_log
    = new G4LogicalVolume(cont2, FindMaterial("G4_Cu"),"SipmContact2",0,0,0);

  G4VPhysicalVolume* cont2_phys
    = new G4PVPlacement(rot2,
			G4ThreeVector(SipmContact2_Xshift, SipmContactYPosition, SipmContact2_Zshift),  
			cont2_log,
			"SipmContact2",
                        setup_log,
			false,
			0,
                        true);

  G4cout << "-----!!!!!!! SiPM contacts constructed !!!!!------" << G4endl;

  // SiPM in box
//
  G4Box* sipm = new G4Box("SipmDet", SipmDX, SipmDY, SipmDZ);

  G4LogicalVolume* sipm_log
    = new G4LogicalVolume(sipm, FindMaterial("G4_Si"),"SipmDet",0,0,0);

  G4VPhysicalVolume* sipm_phys
    = new G4PVPlacement(rot2,
			G4ThreeVector(0.0, SipmYPosition, 0.0),  
			sipm_log,
			"SipmDet",
                        setup_log,
			false,
			0,
                        true);

  G4cout << "-----!!!!!!! SiPM constructed !!!!!------" << G4endl;

//===================================================================
// ------------- Optical surfaces --------------
//===================================================================

  const G4int num = 15;
  G4double ephoton[num] = {2.0*eV, 4.5*eV};
  
// ---------  Tile - Foil

// 3M DF2000 foil
G4double PE_ESR[15] = {
    3.099605*eV, 3.024005*eV, 3.002038*eV, 2.987571*eV, 2.952004*eV,
    2.931068*eV, 2.870004*eV, 2.749095*eV, 2.632361*eV, 2.535464*eV,
    2.450280*eV, 2.375176*eV, 2.304539*eV, 2.221939*eV, 2.152503*eV
};

G4double reflect_foil[15] = {
    0, 79.99894/100., 85.27812/100., 90.12258/100., 95.09099/100.,
    97.82370/100., 99.74816/100., 99.87048/100., 99.24724/100., 98.06532/100.,
    98.80880/100., 99.17989/100., 99.67514/100., 99.67302/100., 99.67117/100.
};

G4double efficiency_ESR[15] = {
    0., 0., 0., 0., 0.,
    0., 0., 0., 0., 0.,
    0., 0., 0., 0., 0.
};

  G4OpticalSurface* tileFoilSurface =
    new G4OpticalSurface("tileFoilSurface",    // name
			 unified,                 // model
			 polished,      // finish
			 dielectric_metal   // type
			 //SIGMA_ALPHA_FOIL         // roughness (sigma alpha)
			 );
  //tileFoilSurface->SetSigmaAlpha(SIGMA_ALPHA_FOIL);

  G4MaterialPropertiesTable* mptTileFoil = new G4MaterialPropertiesTable();
  mptTileFoil->AddProperty("REFLECTIVITY", PE_ESR, reflect_foil, num);
  mptTileFoil->AddProperty("EFFICIENCY", PE_ESR, efficiency_ESR, num);

  G4cout << "Tile-Foil Surface G4MaterialPropertiesTable" << G4endl;
  mptTileFoil->DumpTable();

  tileFoilSurface->SetMaterialPropertiesTable(mptTileFoil);

  new G4LogicalBorderSurface("TilePerimeterSide1",
			     tile_phys, side1_phys, tileFoilSurface);
  new G4LogicalBorderSurface("TilePerimeterSide2",
			     tile_phys, side2_phys, tileFoilSurface);
  new G4LogicalBorderSurface("TilePerimeterSide3",
			     tile_phys, side3_phys, tileFoilSurface);
  new G4LogicalBorderSurface("TilePerimeterSide4",
			     tile_phys, side4_phys, tileFoilSurface);
  new G4LogicalBorderSurface("TilePerimeterSide5",
			     tile_phys, side5_phys, tileFoilSurface);
  new G4LogicalBorderSurface("TilePerimeterSide6",
			     tile_phys, side6_phys, tileFoilSurface);


// ------------ Air - Slab surface

const G4int NUMENTRIES = 14;

G4double reflect_slab[15] = {
	0.99, 0.99, 0.99, 0.99, 0.99,
	0.99, 0.99, 0.99, 0.99, 0.99,
	0.99, 0.99, 0.99, 0.99, 0.99
};

G4double PhotonEnergy[NUMENTRIES] = {
    3.26274*eV, 3.17908*eV, 3.0996*eV,  3.024*eV, 2.952*eV,
    2.88335*eV, 2.81782*eV, 2.7552*eV,  2.69531*eV, 2.63796*eV, 
    2.583*eV,   2.53029*eV, 2.47968*eV, 2.43106*eV
};

G4double refIndex_Air[NUMENTRIES] = {
    1.00029, 1.00029, 1.00029, 1.00029, 1.00029,
    1.00029, 1.00029, 1.00029, 1.00029, 1.00029,
    1.00029, 1.00029, 1.00029, 1.00029
};

  G4OpticalSurface* airSlabSurface = 
    new G4OpticalSurface("AirSlabSurface",
			 unified,
			 polished,
			 dielectric_metal,
			 0.0
			 );

  G4MaterialPropertiesTable* mptAirSlab = new G4MaterialPropertiesTable();

  mptAirSlab->AddProperty("REFLECTIVITY", PE_ESR, reflect_slab, num);
  mptAirSlab->AddProperty("RINDEX",   PhotonEnergy, refIndex_Air, NUMENTRIES);

  G4cout << "Air-Slab Surface G4MaterialPropertiesTable" << G4endl;
  mptAirSlab->DumpTable();

  airSlabSurface->SetMaterialPropertiesTable(mptAirSlab);

  new G4LogicalBorderSurface("AirTopSlabSurface",
			     setup_phys, topSlab_phys, airSlabSurface);

  new G4LogicalBorderSurface("AirBotSlabSurface",
			     setup_phys, botSlab_phys, airSlabSurface);

/*
// ------------ Tile - Slab  surface
  G4OpticalSurface* tileSlabSurface = 
    new G4OpticalSurface("TileSlabSurface",
			 unified,
			 polished,
			 dielectric_metal,
			 0.0
			 );

  G4MaterialPropertiesTable* mptTileSlab = new G4MaterialPropertiesTable();

  mptTileSlab->AddProperty("REFLECTIVITY", ephoton, reflectivity_slab, num);
//  mptTileSlab->AddProperty("EFFICIENCY",   ephoton, efficiency_slab,  num);

  G4cout << "Tile-Slab Surface G4MaterialPropertiesTable" << G4endl;
  mptTileSlab->DumpTable();

  tileSlabSurface->SetMaterialPropertiesTable(mptTileSlab);

  new G4LogicalBorderSurface("TileTopSlabSurface",
			     tile_phys, topSlab_phys, tileSlabSurface);

  new G4LogicalBorderSurface("TileBotSlabSurface",
			     tile_phys, botSlab_phys, tileSlabSurface);
*/  

// ------------  Epoxy SipmBox - Sipm back surface
// surface between box and SiPM back side (which does not detect light) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  G4OpticalSurface* SipmBoxSipmBackSurface = 
    new G4OpticalSurface("SipmBoxSipmBackSurface",

			 unified,
			 polished,
			 dielectric_metal,
			 0.0
			 );

  G4MaterialPropertiesTable* mptEpoxyBox = new G4MaterialPropertiesTable();

  mptEpoxyBox->AddProperty("REFLECTIVITY", PE_ESR, reflect_foil,num);

  G4cout << "EpoxySipmBox-Sipm Surface G4MaterialPropertiesTable" << G4endl;
  mptEpoxyBox->DumpTable();



  SipmBoxSipmBackSurface->SetMaterialPropertiesTable(mptEpoxyBox);

  new G4LogicalBorderSurface("SipmBoxSipmSurface",
			     sipmbox_phys, sipm_phys, SipmBoxSipmBackSurface);
  
  // the same properties for sipmbox-contact surface
  new G4LogicalBorderSurface("SipmBoxContact1Surface",
			     sipmbox_phys, cont1_phys, SipmBoxSipmBackSurface);
  new G4LogicalBorderSurface("SipmBoxContact2Surface",
			     sipmbox_phys, cont2_phys, SipmBoxSipmBackSurface);
  
// ------------ Epoxy - Sipm surface
// surface between epoxy and SiPM WINDOW for light detection !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  G4double reflectSipmWindow[num - 13]    = {0.05, 0.05};

  G4OpticalSurface* epoxySipmSurface = 
    new G4OpticalSurface("EpoxySipmSurface",
			 unified,
			 polished,
			 dielectric_metal,
			 0.0
			 );

  G4MaterialPropertiesTable* mptEpoxySipm = new G4MaterialPropertiesTable();

  mptEpoxySipm->AddProperty("REFLECTIVITY", ephoton, reflectSipmWindow, num - 13);

  G4cout << "Epoxy-Sipm Surface G4MaterialPropertiesTable" << G4endl;
  mptEpoxySipm->DumpTable();

  epoxySipmSurface->SetMaterialPropertiesTable(mptEpoxySipm);

  new G4LogicalBorderSurface("EpoxySipmSurface",
			     epoxy_phys, sipm_phys, epoxySipmSurface);

  
//--------------------------------

//always return the physical World
  return setup_phys;


}

G4VPhysicalVolume*
LYSimDetectorConstruction::Construct2()
{
  static const bool checkOverlaps = true;

  ///////////////////////////////////////////////////////////////////////////////
  // World volume
  ///////////////////////////////////////////////////////////////////////////////
  G4Box* solidWorld = new G4Box( "World", WorldHalfX()
                               , WorldHalfY(), WorldHalfZ() );

  G4LogicalVolume* logicWorld = new G4LogicalVolume( solidWorld, fAir, "World" );

  G4VPhysicalVolume* physWorld = new G4PVPlacement( 0
                                                  , G4ThreeVector( 0, 0, 0 )
                                                  , logicWorld
                                                  , "World"
                                                  , 0
                                                  , false
                                                  , 0
                                                  , checkOverlaps );
  ///////////////////////////////////////////////////////////////////////////////
  // wrapping
  ///////////////////////////////////////////////////////////////////////////////
  G4VSolid* solidWrap = ConstructHollowWrapSolid();
  G4VSolid* solidWrapGap = ConstructHollowWrapGapSolid();
  // The matrial of the wrap isn't as important as the surface
  G4LogicalVolume* logicWrap = new G4LogicalVolume( solidWrap, fEpoxy,  "Wrap" );
  G4LogicalVolume* logicWrapGap = new G4LogicalVolume( solidWrapGap, fBC_630_grease,  "WrapGap" );
  const G4ThreeVector tile_offset( 0, 0
                                , -0.5*(_tilez*(tile_number-1) + tilegap*(tile_number-1)));

  G4VPhysicalVolume* physWrap = new G4PVPlacement( 0
                                                 , tile_offset
                                                 , logicWrap
                                                 , "Wrap"
                                                 , logicWorld
                                                 , false
                                                 , 0
                                                 , checkOverlaps );
/*
  G4VPhysicalVolume* physWrapGap = new G4PVPlacement( 0
                                                 , tile_offset
                                                 , logicWrapGap
                                                 , "WrapGap"
                                                 , logicWorld
                                                 , false
                                                 , 0
                                                 , checkOverlaps );
*/
  // Exposed PCB Back plane
  const G4ThreeVector pcb_offset( 0, 0
                                , 0.5*_tilez + wrapgap + 2*wrapthickness +_gap_pcb_wrap_ );

  G4VSolid* solidPCB = new G4Tubs( "PCBSolid"
                                 , 0, _pcb_radius + 1*mm
                                 , wrapthickness
                                 , 0, 2*pi );
  G4LogicalVolume* logicPCB = new G4LogicalVolume( solidPCB, fEpoxy, "PCB" );

  G4VPhysicalVolume* physPCB = new G4PVPlacement( 0, pcb_offset
                                                , logicPCB, "PCB"
                                                , logicWorld, false
                                                , 0, checkOverlaps  );

  ///////////////////////////////////////////////////////////////////////////////
  // Subtracted Dimple Version (dimple sub from tile, WWW = mothervolume of both)
  ///////////////////////////////////////////////////////////////////////////////
  G4VSolid* solidTile = ConstructTrapazoidSolid( "TileTrap"
                                               , _tilex
                                               , _tiley
                                               , _tilez
                                               , _tile_x1
                                               , _tile_x2 );

  G4VSolid* solidTileSubtract = new G4Sphere( "TileSub", 0, GetDimpleSizeRadius()
                                            , 0, 2* pi, 0, pi );

  G4VSolid* hollowedTile = new G4SubtractionSolid( "TileSolid"
                                                 , solidTile, solidTileSubtract
                                                 , 0, CalcDimpleOffset() );

  G4LogicalVolume* logicTile = new G4LogicalVolume( hollowedTile
                                                  , fEJ200, "TileLogic" );

  G4VPhysicalVolume* physTile = new G4PVPlacement( 0
                                                 , G4ThreeVector( 0, 0, 0 )
                                                 , logicTile
                                                 , "TilePhysic"
                                                 , logicWorld
                                                 , false
                                                 , 0
                                                 , checkOverlaps );


  ///////////////////////////////////////////////////////////////////////////////
  // put more tile layers and grease
  ///////////////////////////////////////////////////////////////////////////////

  G4LogicalVolume* mlogicTile= new G4LogicalVolume( solidTile
                                               , fEJ200, "mTileLogic" );

  std::vector<G4VPhysicalVolume*> mphysTileList;

  G4VSolid* msolidGrease = ConstructTrapazoidSolid( "GreaseTrap"
                                               , _tilex
                                               , _tiley
                                               , tilegap
                                               , _tile_x1
                                               , _tile_x2 );
  G4LogicalVolume* mlogicGrease= new G4LogicalVolume( msolidGrease
                                               , fBC_630_grease, "GreaseLogic" );

  std::vector<G4VPhysicalVolume*> mphysGreaseList;

  for(int i=1; i<tile_number; i++){

      mphysGreaseList.push_back( new G4PVPlacement(0, G4ThreeVector( 0, 0, -1*(_tilez+tilegap)*i+0.5*(_tilez+tilegap) ), mlogicGrease
                                               , "GreasePhysic"
                                               , logicWorld
                                               , false
                                               , 0
                                               , checkOverlaps)); 

      mphysTileList.push_back( new G4PVPlacement(0
                                               , G4ThreeVector( 0, 0, -1*(_tilez+tilegap)*i )
                                               , mlogicTile
                                               , "mTilePhysic"
                                               , logicWorld
                                               , false
                                               , 0
                                               , checkOverlaps ));

  }





  ///////////////////////////////////////////////////////////////////////////////
  // SiPM
  ///////////////////////////////////////////////////////////////////////////////


  double extra_l = 0.53*mm;
  double thin_surrounding = 0.01*mm;


  G4Box* solidSiPMactive = new G4Box( "SiPMDead"
                                  , 0.5*_sipm_x, 0.5*_sipm_y
                                  , _sipm_z );

  G4Box* solidSiPMInnerBox = new G4Box( "SiPMInnerBox"
                                      , 0.5*_sipm_x+thin_surrounding, 0.5*_sipm_y+thin_surrounding
                                      ,  0.5*_sipm_z);


  G4VSolid* solidSiPMCase
    = new G4SubtractionSolid( "SiPMCase"
                            , solidSiPMInnerBox, solidSiPMactive
                            , 0
                            , G4ThreeVector( 0, 0, 0 ) );

  G4VSolid* solidSiPMInner
    = new G4IntersectionSolid( "SiPMInner"
                             , solidSiPMInnerBox, solidSiPMactive
                             , 0
                             , G4ThreeVector( 0, 0, 0 ) );

  G4Box* solidSiPMResinOuter
    = new G4Box( "SiPMResinOuter"
               , 0.5*_sipm_x + _sipm_rimwidth + 0.5*extra_l
               , 0.5*_sipm_y + _sipm_rimwidth
               , 0.5*_sipm_z + 0.5*_sipm_glasswidth );

  G4VSolid* solidSiPMResin
    = new G4SubtractionSolid( "SiPMResin"
                            , solidSiPMResinOuter, solidSiPMInnerBox
                            ,  0
                            , G4ThreeVector( 0.5*extra_l, 0, 0.5*_sipm_glasswidth ) );
  G4Box* solidSiPMStand
    = new G4Box( "SiPMStand"
               , 0.5*_sipm_x+_sipm_rimwidth + 0.5*extra_l
               , 0.5*_sipm_y+_sipm_rimwidth
               , 0.5*_sipm_standz_ );


  G4LogicalVolume* logicSiPM = new G4LogicalVolume( solidSiPMInner
                                                  , fBialkali,  "SiPM" );

  G4LogicalVolume* logicSiPMCase = new G4LogicalVolume( solidSiPMCase
                                                      , fEpoxy, "SiPMBack" );

  G4LogicalVolume* logicSiPMResin = new G4LogicalVolume( solidSiPMResin
                                                       , fResin, "SiPMResin" );

  G4LogicalVolume* logicSiPMStand = new G4LogicalVolume( solidSiPMStand
                                                       , fEpoxy, "SiPMStand" );


double xy_shift = 1.7*mm;
double xd=xy_shift/sqrt(2);
double yd=xy_shift/sqrt(2);

if(material==1){
    xd = xd*(-1);
}else if(material==2){
}else if(material==3){
    yd = yd*(-1);
}else if(material==4){
    xd = xd*(-1);
    yd = yd*(-1);
}else{
    xd = 0;
    yd = 0;
}

xd=_sipm_standz;
yd=_gap_pcb_wrap;

xd=0;
yd=0;

  const G4ThreeVector SiPMOffset( xd, yd
                                , +0.5*_tilez - 0.5*_sipm_z - _sipm_standz_ +wrapgap+wrapthickness +_gap_pcb_wrap_);
  const G4ThreeVector ResinOffset( -0.5*extra_l+xd, yd
                                 , +0.5*_tilez - 0.5*_sipm_z - _sipm_standz_
                                   - 0.5*_sipm_glasswidth +wrapgap+wrapthickness +_gap_pcb_wrap_);
  const G4ThreeVector StandOffset( -0.5*extra_l+xd, yd, +0.5*_tilez - 0.5*_sipm_standz_+wrapgap+wrapthickness +_gap_pcb_wrap_);

  G4VPhysicalVolume* physSiPMStand = new G4PVPlacement( 0
                                                      , StandOffset
                                                      , logicSiPMStand
                                                      , "SiPMStand"
                                                      , logicWorld
                                                      , false
                                                      , 0
                                                      , checkOverlaps );

  G4VPhysicalVolume* physSiPMCase = new G4PVPlacement( 0
                                                     , SiPMOffset
                                                     , logicSiPMCase
                                                     , "Case"
                                                     , logicWorld
                                                     , false
                                                     , 0
                                                     , checkOverlaps );

  G4VPhysicalVolume* physSiPMResin = new G4PVPlacement( 0
                                                      , ResinOffset
                                                      , logicSiPMResin
                                                      , "SiPMResin"
                                                      , logicWorld
                                                      , false
                                                      , 0
                                                      , checkOverlaps  );

  G4VPhysicalVolume* physSiPM = new G4PVPlacement( 0
                                                 , SiPMOffset
                                                 , logicSiPM
                                                 , "SiPM"
                                                 , logicWorld
                                                 , false
                                                 , 0
                                                 , checkOverlaps );





/*
  G4Box* solidSiPMDead = new G4Box( "SiPMDead"
                                  , 0.5*_sipm_deadwidth, 0.5*_sipm_deadwidth
                                  , _sipm_z );

  G4Box* solidSiPMInnerBox = new G4Box( "SiPMInnerBox"
                                      , 0.5*_sipm_x, 0.5*_sipm_y,  0.8*_sipm_z );

  G4Box* solidSiPMOuter = new G4Box( "SiPMOuter"
                                   , 0.5*_sipm_x + _sipm_rimwidth
                                   , 0.5*_sipm_y + _sipm_rimwidth
                                   , 0.5*_sipm_z );
  G4Box* solidSiPMStand
    = new G4Box( "SiPMStand"
               , 0.5*_sipm_x+_sipm_rimwidth + _sipm_glasswidth
               , 0.5*_sipm_y+_sipm_rimwidth + _sipm_glasswidth
               , 0.5*_sipm_standz );

  G4Box* solidSiPMResinOuter
    = new G4Box( "SiPMResinOuter"
               , 0.5*_sipm_x + _sipm_rimwidth + _sipm_glasswidth
               , 0.5*_sipm_y + _sipm_rimwidth + _sipm_glasswidth
               , 0.5*_sipm_z + _sipm_glasswidth );

  G4VSolid* solidSiPMSubtract
    = new G4SubtractionSolid( "SiPMSubtract"
                            ,  solidSiPMInnerBox, solidSiPMDead
                            ,   0, G4ThreeVector( 0, 0, 0 ) );
  G4VSolid* solidSiPMCase
    = new G4SubtractionSolid( "SiPMCase"
                            , solidSiPMOuter, solidSiPMSubtract
                            , 0
                            , G4ThreeVector( 0, 0, -0.65 * _sipm_z ) );

  G4VSolid* solidSiPMInner
    = new G4IntersectionSolid( "SiPMInner"
                             , solidSiPMOuter, solidSiPMSubtract
                             , 0
                             , G4ThreeVector( 0, 0, -0.65*_sipm_z ) );

  G4VSolid* solidSiPMResin
    = new G4SubtractionSolid( "SiPMResin"
                            , solidSiPMResinOuter, solidSiPMOuter
                            ,  0
                            , G4ThreeVector( 0, 0, _sipm_glasswidth ) );


  G4LogicalVolume* logicSiPM = new G4LogicalVolume( solidSiPMInner
                                                  , fBialkali,  "SiPM" );

  G4LogicalVolume* logicSiPMCase = new G4LogicalVolume( solidSiPMCase
                                                      , fEpoxy, "SiPMBack" );

  G4LogicalVolume* logicSiPMResin = new G4LogicalVolume( solidSiPMResin
                                                       , fResin, "SiPMResin" );

  G4LogicalVolume* logicSiPMStand = new G4LogicalVolume( solidSiPMStand
                                                       , fEpoxy, "SiPMStand" );

  const G4ThreeVector SiPMOffset( 0, 0
                                , +0.5*_tilez - 0.5*_sipm_z - _sipm_standz +wrapgap+wrapthickness);
  const G4ThreeVector ResinOffset( 0, 0
                                 , +0.5*_tilez - 0.5*_sipm_z - _sipm_standz
                                   - _sipm_glasswidth +wrapgap+wrapthickness);
  const G4ThreeVector StandOffset( 0, 0, +0.5*_tilez - 0.5*_sipm_standz +wrapgap+wrapthickness);

  G4VPhysicalVolume* physSiPMStand = new G4PVPlacement( 0
                                                      , StandOffset
                                                      , logicSiPMStand
                                                      , "SiPMStand"
                                                      , logicWorld
                                                      , false
                                                      , 0
                                                      , checkOverlaps );

  G4VPhysicalVolume* physSiPMCase = new G4PVPlacement( 0
                                                     , SiPMOffset
                                                     , logicSiPMCase
                                                     , "Case"
                                                     , logicWorld
                                                     , false
                                                     , 0
                                                     , checkOverlaps );

  G4VPhysicalVolume* physSiPMResin = new G4PVPlacement( 0
                                                      , ResinOffset
                                                      , logicSiPMResin
                                                      , "SiPMResin"
                                                      , logicWorld
                                                      , false
                                                      , 0
                                                      , checkOverlaps  );

  G4VPhysicalVolume* physSiPM = new G4PVPlacement( 0
                                                 , SiPMOffset
                                                 , logicSiPM
                                                 , "SiPM"
                                                 , logicWorld
                                                 , false
                                                 , 0
                                                 , checkOverlaps );

*/

  ///////////////////////////////////////////////////////////////////////////////
  // Defining surfaces
  ///////////////////////////////////////////////////////////////////////////////
  //G4LogicalBorderSurface* WrapAirSurface;
  if (is_ESR){
  G4LogicalBorderSurface* WrapAirSurface = new G4LogicalBorderSurface( "WrapAirSurface"
                              , physWorld
                              , physWrap
                              , fESROpSurface );
  }else{
  G4LogicalBorderSurface*  WrapAirSurface = new G4LogicalBorderSurface( "WrapAirSurface"
                              , physWorld
                              , physWrap
                              , fTyvekSurface );
  }

  G4LogicalBorderSurface* TileSurface =
    new G4LogicalBorderSurface( "TileSurface"
                              , physTile
                              , physWorld
                              , fIdealPolishedOpSurface );
  std::vector<G4LogicalBorderSurface*> mTileSurfaceList;
  std::vector<G4LogicalBorderSurface*> mGreaseSurfaceList;

  for(int i=1; i<tile_number; i++){
    mTileSurfaceList.push_back( new G4LogicalBorderSurface(
                               "mTileSurface"
                              , mphysTileList.at(i-1)
                              , physWorld
                              , fIdealPolishedOpSurface) );    


    mGreaseSurfaceList.push_back( new G4LogicalBorderSurface(
                               "mGreaseSurface"
                              , mphysGreaseList.at(i-1)
                              , physWorld
                              , fIdealPolishedOpSurface) );
  }
  G4LogicalSkinSurface* CaseSurface
    = new G4LogicalSkinSurface( "SiPMCaseSurface"
                              , logicSiPMCase
                              , fIdealWhiteOpSurface );
  G4LogicalSkinSurface* StandSurface
    = new G4LogicalSkinSurface( "SiPMStandSurface"
                              , logicSiPMStand
                              , fIdealWhiteOpSurface );
  G4LogicalSkinSurface* SiPMSurface
    = new G4LogicalSkinSurface( "SiPMSurface", logicSiPM, fSiPMSurface );
  G4LogicalSkinSurface* PCBSurface
    = new G4LogicalSkinSurface( "PCBSurface", logicPCB, fPCBSurface );

  // Setting the sensitive detector
  if( !fPMTSD ){
    fPMTSD = new LYSimPMTSD( "/LYSimPMT" );
    G4SDManager* sdman = G4SDManager::GetSDMpointer();
    sdman->AddNewDetector( fPMTSD );
  }
  logicSiPM->SetSensitiveDetector( fPMTSD );

  // Visual attributes
  logicWorld->SetVisAttributes( G4VisAttributes::Invisible );

  G4VisAttributes* SiPMVisAtt = new G4VisAttributes( G4Colour( 0, 0, 0 ) );
  SiPMVisAtt->SetForceSolid( true );
  SiPMVisAtt->SetVisibility( true );
  logicSiPM->SetVisAttributes( SiPMVisAtt );

  G4VisAttributes* CaseVisAtt = new G4VisAttributes( G4Colour( 0.8, 0.8, 0.8 ) );
  CaseVisAtt->SetForceSolid( true );
  CaseVisAtt->SetVisibility( true );
  logicSiPMCase->SetVisAttributes( CaseVisAtt );
  logicSiPMStand->SetVisAttributes( CaseVisAtt );

//  G4VisAttributes* ResinVisAtt = new G4VisAttributes( G4Colour( 0., 1., 1. ) );
//  ResinVisAtt->SetForceWireframe( true );
//  ResinVisAtt->SetVisibility( true );
//  logicSiPMResin->SetVisAttributes( ResinVisAtt );

  G4VisAttributes* TileVisAtt = new G4VisAttributes( G4Colour( 1., 1., 0. ) );
  TileVisAtt->SetForceWireframe( true );
  TileVisAtt->SetVisibility( true );
  logicTile->SetVisAttributes( TileVisAtt );

  mlogicTile->SetVisAttributes( TileVisAtt );

  G4VisAttributes* GreaseVisAtt = new G4VisAttributes( G4Colour( 1.0, 1.0, 1.0 ) );
  //GreaseVisAtt->SetForceWireframe( true );
  GreaseVisAtt->SetVisibility( true );
  mlogicGrease->SetVisAttributes( GreaseVisAtt );

  G4VisAttributes* WrapVisAtt = new G4VisAttributes( G4Colour( 0.5, 1., 0.5 ) );
  WrapVisAtt->SetForceWireframe( true );
  WrapVisAtt->SetVisibility( true );
  logicWrap->SetVisAttributes( WrapVisAtt );

  G4VisAttributes* PCBVisAtt = new G4VisAttributes( G4Colour( 0.0, 0.4, 0.1 ) );
  PCBVisAtt->SetForceSolid( true );
  PCBVisAtt->SetVisibility( true );
  logicPCB->SetVisAttributes( PCBVisAtt );

  return physWorld;
}

G4VSolid*
LYSimDetectorConstruction::ConstructTrapazoidSolid(
  const G4String& name,
  double          x,
  double          y,
  double          z,
  double          indent_x1,
  double          indent_x2 ) const
{
  const G4ThreeVector corners[8] = {
    G4ThreeVector( -x/2,           -y/2, -z/2 ),
    G4ThreeVector( x/2,            -y/2, -z/2 ),
    G4ThreeVector( -x/2+indent_x2, y/2,  -z/2 ),
    G4ThreeVector( x/2-indent_x1,  y/2,  -z/2 ),
    G4ThreeVector( -x/2,           -y/2, z/2 ),
    G4ThreeVector( x/2,            -y/2, z/2 ),
    G4ThreeVector( -x/2+indent_x2, y/2,  z/2 ),
    G4ThreeVector( x/2-indent_x1,  y/2,  z/2 )
  };

  return new G4Trap( name, corners );
}

G4VSolid*
LYSimDetectorConstruction::ConstructHollowWrapSolid() const
{
  G4VSolid* wrapOuter
    = ConstructTrapazoidSolid( "WrapOuter"
                             , _tilex + 2*wrapgap + 2*wrapthickness
                             , _tiley + 2*wrapgap + 2*wrapthickness
                             , _tilez*tile_number + tilegap*(tile_number-1) + 2*wrapgap + 2*wrapthickness
                             , 0, 0 );
  G4VSolid* wrapInner
    = ConstructTrapazoidSolid( "WrapInner"
                             , _tilex + 2*wrapgap
                             , _tiley + 2*wrapgap
                             , _tilez*tile_number + tilegap*(tile_number-1) + 2*wrapgap
                             , 0, 0 );
  G4VSolid* wrapbox = new G4SubtractionSolid( "WrapBox"
                                            , wrapOuter, wrapInner );
  G4VSolid* wraphole = new G4Tubs( "WrapHole"
                                 , 0, _pcb_radius
                                 , 2*wrapthickness
                                 , 0, 2*pi );

  const G4ThreeVector offset( 0, 0, 0.5*(_tilez*tile_number + tilegap*(tile_number-1)) + wrapgap + 0.5*wrapthickness );

  return new G4SubtractionSolid( "WrapSolid"
                               , wrapbox, wraphole
                               , NULL, offset );
}

G4VSolid*
LYSimDetectorConstruction::ConstructHollowWrapGapSolid() const
{
  G4VSolid* wrapgapOuter
    = ConstructTrapazoidSolid( "WrapGapOuter"
                             , _tilex + 2*wrapgap
                             , _tiley + 2*wrapgap
                             , _tilez*tile_number + tilegap*(tile_number-1) + 2*wrapgap
                             , 0, 0 );
  G4VSolid* wrapgapInner
    = ConstructTrapazoidSolid( "WrapGapInner"
                             , _tilex 
                             , _tiley
                             , _tilez*tile_number + tilegap*(tile_number-1)
                             , 0, 0 );
  G4VSolid* wrapgapbox = new G4SubtractionSolid( "WrapGapBox"
                                            , wrapgapOuter, wrapgapInner );
  G4VSolid* wrapgaphole = new G4Tubs( "WrapGapHole"
                                 , 0, _pcb_radius
                                 , 2*wrapthickness
                                 , 0, 2*pi );

  const G4ThreeVector offset( 0, 0, 0.5*(_tilez*tile_number + tilegap*(tile_number-1)) + wrapgap + 0.5*wrapthickness );

  return new G4SubtractionSolid( "WrapGapSolid"
                               , wrapgapbox, wrapgaphole
                               , NULL, offset );
}


G4VSolid*
LYSimDetectorConstruction::ConstructSphereDimpleSolid() const
{
  G4Sphere* solidsphere = new G4Sphere( "DimpleSphere"
                                      , 0, GetDimpleSizeRadius()
                                      , 0.,  2.*pi
                                      , pi/2, pi );

  G4Box* solidsub = new G4Box( "DimpleSphereSubBox"
                             , GetDimpleSizeRadius(), GetDimpleSizeRadius()
                             , GetDimpleSizeRadius() - GetDimpleIndent() );

  return new G4SubtractionSolid( "Dimple", solidsphere, solidsub );
}

G4VSolid*
LYSimDetectorConstruction::ConstructParabolicDimpleSolid() const
{
  const G4double SemiZ = ( 447317/288000 )*mm + _dimple_indent;
  const G4double SemiX = ( 447317/120000 )*mm;

  return new G4Ellipsoid( "DimpleParabolic",
    SemiX,
    SemiX,
    SemiZ,
    -SemiZ,// must be < SemiZ
    -SemiZ+_dimple_indent );// must be >-SemiZ
}

G4VSolid*
LYSimDetectorConstruction::ConstructPyramidDimpleSolid() const
{
  return new G4Trd( "DimplePyramid",
    0.0*mm, _dimple_radius,
    0.0*mm, _dimple_radius,
    _dimple_indent*0.5 );
}

double
LYSimDetectorConstruction::GetDimpleSizeRadius() const
{
  return 0.5*( ( _dimple_radius*_dimple_radius )/_dimple_indent
               + _dimple_indent );
}

G4ThreeVector
LYSimDetectorConstruction::CalcDimpleOffset() const
{
  if( _dimple_type == PYRAMID ){
    return G4ThreeVector( 0, 0, 0.5*_tilez-0.5*_dimple_indent );
  } else if( _dimple_type == PARABOLIC ){
    return G4ThreeVector( 0, 0, 0.5*_tilez+( 447317/288000 )*mm );
  } else {
    return G4ThreeVector( 0, 0
                        , 0.5*_tilez+GetDimpleSizeRadius()-GetDimpleIndent() );
  }
}

G4ThreeVector
LYSimDetectorConstruction::CalcSiPMDimpleOffset() const
{
  if( _dimple_type == PYRAMID ){
    return G4ThreeVector( 0, 0, 0.5*_dimple_indent - 0.5*_sipm_z );
  } else if( _dimple_type == PARABOLIC ){
    return G4ThreeVector( 0, 0, 0 );// TO-DO!!
  } else {
    return G4ThreeVector( 0, 0,
      -GetDimpleSizeRadius() + GetDimpleIndent()- 0.5*_sipm_z );
  }
}

// Additional geometry factors
double
LYSimDetectorConstruction::WorldHalfX() const
{
  return _tilex * 1.5;
}

double
LYSimDetectorConstruction::WorldHalfY() const
{
  return _tiley *1.5;
}

double
LYSimDetectorConstruction::WorldHalfZ() const
{
  return _tilez * 10;
}

double
LYSimDetectorConstruction::LocalTileZ( const double x, const double y ) const
{
  const double dimple_r  = GetDimpleRadius();
  const double dimple_i  = GetDimpleIndent();
  const double beam_r    = sqrt( x*x+y*y );
  const double big_r     = GetDimpleSizeRadius();
  const double thickness = GetTileZ()-Gettgap()*(Gettn()-1);
  const int type         = GetDimpleType();

  if( beam_r <= dimple_r ){
    if( type == SPHERICAL ){
      return thickness - ( sqrt( big_r*big_r - beam_r*beam_r ) -
                           ( big_r - dimple_i ) );
    } else if( type == PARABOLIC ){//  # Parabolic
      return thickness - abs( 1.35 * beam_r*beam_r - dimple_i );
    } else if( type == PYRAMID ){
      if( fabs( y ) <= fabs( x ) ){
        return thickness - ( dimple_i - ( dimple_i / dimple_r ) * fabs( x ) );
      } else {
        return thickness - ( dimple_i - ( dimple_i / dimple_r ) * fabs( y ) );
      }
    }  else {
      return thickness;
    }
  } else {
    return thickness;
  }
}


void
LYSimDetectorConstruction::SetTileAbsMult( const double mult )
{
  _absmult = mult;
  Update_EJ200_AbsLength( fEJ200, _absmult );
}

void
LYSimDetectorConstruction::SetWrapReflect( const double r )
{
  // Add entries into properties table
  _wrap_reflect = r;
  static const unsigned nentries = 2;
  static double phoE[nentries]   = {1.0*eV, 6.0*eV};
  double reflectivity[nentries]  = {_wrap_reflect, _wrap_reflect};

  G4MaterialPropertiesTable* table = fESROpSurface->GetMaterialPropertiesTable();
  if( table ){
    table->RemoveProperty( "REFLECTIVITY" );
    table->AddProperty( "REFLECTIVITY", phoE, reflectivity, nentries );
  } else {
    table = new G4MaterialPropertiesTable();
    table->AddProperty( "REFLECTIVITY", phoE, reflectivity, nentries );
    fESROpSurface->SetMaterialPropertiesTable( table );
  }

  static const unsigned nentriesty = 26;
  static double phoEty[nentriesty]   = {4.943804623    *eV,
4.69950395    *eV,
4.410663534    *eV,
4.305769181    *eV,
4.178097005    *eV,
3.98967036    *eV,
3.76463744    *eV,
3.504566212    *eV,
3.297986987    *eV,
3.134959329    *eV,
2.977941044    *eV,
2.859341507    *eV,
2.724238775    *eV,
2.569705793    *eV,
2.390512946    *eV,
2.26527967    *eV,
2.154957608    *eV,
2.036186213    *eV,
1.936699241    *eV,
1.839342514    *eV,
1.770863763    *eV,
1.705769441    *eV,
1.659646089    *eV,
1.609116456    *eV,
1.565425358    *eV,
1.550120187    *eV};

 double reflectivityty[nentriesty]  = {0.823738509    *_wrap_reflect,
0.842890705    *_wrap_reflect,
0.878426966    *_wrap_reflect,
0.906639428    *_wrap_reflect,
0.913942799    *_wrap_reflect,
0.933105209    *_wrap_reflect,
0.952277835    *_wrap_reflect,
0.96784474    *_wrap_reflect,
0.98340143    *_wrap_reflect,
0.988937692    *_wrap_reflect,
0.989948927    *_wrap_reflect,
0.992747702    *_wrap_reflect,
0.991940756    *_wrap_reflect,
0.993881512    *_wrap_reflect,
0.99587334    *_wrap_reflect,
0.996905005    *_wrap_reflect,
0.997037794    *_wrap_reflect,
0.999918284    *_wrap_reflect,
0.997334014    *_wrap_reflect,
0.998396323    *_wrap_reflect,
0.998518897    *_wrap_reflect,
1    *_wrap_reflect,
0.99691522    *_wrap_reflect,
0.995209397    *_wrap_reflect,
0.999846782    *_wrap_reflect,
1    *_wrap_reflect };


  G4MaterialPropertiesTable* tablet = fTyvekSurface->GetMaterialPropertiesTable();
  if( tablet ){
    tablet->RemoveProperty( "REFLECTIVITY" );
    tablet->AddProperty( "REFLECTIVITY", phoEty, reflectivityty, nentriesty );
  } else {
    tablet = new G4MaterialPropertiesTable();
    tablet->AddProperty( "REFLECTIVITY", phoEty, reflectivityty, nentriesty );
    fTyvekSurface->SetMaterialPropertiesTable( tablet );
  }
}

void
LYSimDetectorConstruction::SetPCBReflect( const double r )
{
  // Add entries into properties table
  _pcb_reflectivity = r;
  static const unsigned nentries = 2;
  static double phoE[nentries]   = {1.0*eV, 6.0*eV};
  double reflectivity[nentries]  = {r, r};

  G4MaterialPropertiesTable* table = fPCBSurface->GetMaterialPropertiesTable();
  if( table ){
    table->RemoveProperty( "REFLECTIVITY" );
    table->AddProperty( "REFLECTIVITY", phoE, reflectivity, nentries );
  } else {
    table = new G4MaterialPropertiesTable();
    table->AddProperty( "REFLECTIVITY", phoE, reflectivity, nentries );
    fPCBSurface->SetMaterialPropertiesTable( table );
  }
}

void
LYSimDetectorConstruction::FindMaterial(G4String name) {
    G4Material* material = G4Material::GetMaterial(name,true);
    return material;
}


